# Renomate - Cursor AI Rules
# ===========================
# This file defines the core principles and rules that MUST be followed when
# working on the Renomate codebase. These rules ensure clean, lightweight,
# responsive code that's built for easy manageable scale.
#
# NOTE: This file itself should NEVER be modified without explicit user approval.
# If improvements are needed, suggest them but do not implement without permission.

## üéØ Core Philosophy

### Clean Code
- Write code that is self-documenting with clear variable/function names
- Avoid unnecessary complexity - prefer simple, readable solutions
- Remove dead code immediately - never leave commented-out code
- Keep functions focused on a single responsibility (SRP)
- Use meaningful comments only for complex logic, not obvious operations

### Lightweight Architecture
- Minimize dependencies - only add packages when absolutely necessary
- Use built-in browser APIs when possible instead of libraries
- Avoid heavy UI frameworks for simple components
- Optimize bundle size - lazy load when appropriate
- Use efficient data structures (Map, Set where applicable)

### Responsive Performance
- Target < 50ms response time for user interactions
- Use throttling/debouncing for expensive operations (mousemove, scroll, resize)
- Minimize re-renders - use refs for values that don't affect UI
- Avoid inline object/array creation in render (causes unnecessary re-renders)
- Use React.memo, useMemo, useCallback strategically (not everywhere)

### Scalable Design
- Centralized state management (Zustand store)
- Modular component structure with clear boundaries
- Type safety with TypeScript for all code
- Database-first architecture with proper migrations
- Clear separation: UI ‚Üî Business Logic ‚Üî Data Layer

---

## üìÇ Project Structure

```
src/
‚îú‚îÄ‚îÄ components/          # React components
‚îÇ   ‚îú‚îÄ‚îÄ ui/             # Reusable UI primitives (shadcn/ui)
‚îÇ   ‚îú‚îÄ‚îÄ floormap/       # Floor planner canvas & tools
‚îÇ   ‚îî‚îÄ‚îÄ project/        # Project management components
‚îú‚îÄ‚îÄ pages/              # Top-level route components
‚îú‚îÄ‚îÄ hooks/              # Custom React hooks
‚îú‚îÄ‚îÄ lib/                # Utility functions & helpers
‚îú‚îÄ‚îÄ services/           # External API integrations
‚îú‚îÄ‚îÄ integrations/       # Supabase client & types
‚îî‚îÄ‚îÄ i18n/               # Internationalization

supabase/
‚îú‚îÄ‚îÄ migrations/         # Database schema changes (timestamped)
‚îî‚îÄ‚îÄ *.sql              # Ad-hoc SQL scripts (must be idempotent)
```

**File Organization Rules:**
- Keep files under 500 lines - split if larger
- Group related functionality in directories
- Use index.ts for clean exports when needed
- Colocate types with their components when component-specific

---

## üî∑ TypeScript Rules

### Type Safety (MANDATORY)
```typescript
// ‚úÖ GOOD - Explicit types for function parameters and returns
function calculateArea(width: number, height: number): number {
  return width * height;
}

// ‚ùå BAD - Implicit any types
function calculateArea(width, height) {
  return width * height;
}
```

### Type Definitions
- Define interfaces in `types.ts` when shared across multiple files
- Use type unions for string literals: `type Tool = 'select' | 'wall' | 'door'`
- Use `interface` for object shapes that may be extended
- Use `type` for unions, intersections, and utility types
- Never use `any` - use `unknown` if type is truly unknown

### Coordinate System Types
```typescript
// All coordinates stored in millimeters (mm)
// Canvas uses pixel-to-mm conversion based on zoom/scale
interface LineCoordinates {
  x1: number; // mm
  y1: number; // mm
  x2: number; // mm
  y2: number; // mm
}
```

---

## ‚öõÔ∏è React Best Practices

### Component Structure & Scope (CRITICAL)
```typescript
// ‚úÖ GOOD - Module-level components can access module-level functions
const moduleHelperFunction = (id: string, refs: Map<string, Node>) => {
  // Helper available to all components
};

const MyComponent = React.memo<Props>(({ id, name, refs }) => {
  // Can call moduleHelperFunction(id, refs)
  return <div>...</div>;
});

// ‚ùå BAD - Component-level function not accessible to module components
export const ParentComponent = () => {
  const helperFunction = useCallback(...); // ‚Üê Inside component
  
  return <ChildComponent />; // ‚Üê Can't access helperFunction if defined outside
};

const ChildComponent = React.memo(() => {
  // ERROR: helperFunction is not defined!
  // helperFunction(); // ‚Üê Not in scope
});
```

**Scope Rules:**
- Module-level (`React.memo`) components = Can ONLY access module-level functions
- Component-level functions (inside parent) = Must be passed as props
- Always define shared utilities at module level, before components
- If function uses refs/state, pass them as parameters, not via closure

### Component Props (CRITICAL)
```typescript
// ‚úÖ GOOD - Props match interface AND destructuring
interface Props {
  name: string;
  age: number;
  refs: Map<string, Node>; // Added to interface
}

const MyComponent = ({ name, age, refs }: Props) => {
  // ‚úÖ All props from interface are destructured
  return <div>{name}</div>;
};

// ‚ùå BAD - Added to interface but forgot to destructure
interface Props {
  name: string;
  refs: Map<string, Node>; // Added
}

const MyComponent = ({ name }: Props) => {
  // ‚ùå ERROR: refs is not defined (forgot to destructure)
  return <div>{refs.size}</div>;
};
```

**Props Rules:**
1. When adding prop to interface, ALWAYS add to destructuring
2. When removing prop, remove from BOTH interface AND destructuring
3. Test component render after prop changes
4. TypeScript won't catch missing destructuring if prop is unused

### Component Organization
```typescript
// ‚úÖ GOOD - Clean component with proper hooks
export const MyComponent = ({ projectId }: Props) => {
  // 1. Hooks first
  const store = useFloorMapStore();
  const [localState, setLocalState] = useState<string>('');
  
  // 2. Refs for non-reactive values
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  // 3. Callbacks with proper dependencies
  const handleClick = useCallback(() => {
    // Implementation
  }, [/* minimal deps */]);
  
  // 4. Effects last
  useEffect(() => {
    // Side effects
  }, []);
  
  // 5. Return JSX
  return <div>...</div>;
};
```

### State Management

**Zustand Store (Global State):**
```typescript
// ‚úÖ GOOD - Read fresh state in callbacks to avoid dependency issues
const handleClick = useCallback(() => {
  const currentShapes = useFloorMapStore.getState().shapes;
  // Use currentShapes...
}, []); // No dependencies needed

// ‚ùå BAD - Using closure variables causes stale state
const shapes = useFloorMapStore(state => state.shapes);
const handleClick = useCallback(() => {
  // shapes might be stale!
}, [shapes]); // Unnecessary dependency
```

**Local State (useState):**
- Use for UI-only state (modals, input values, etc.)
- Avoid for data that needs to persist or be shared
- Keep state as close to where it's used as possible

### Hook Dependencies
```typescript
// ‚úÖ GOOD - Minimal, stable dependencies
const handleDrag = useCallback((e: DragEvent) => {
  const { x, y } = useStore.getState().position;
  // ...
}, []); // Read from store directly, no deps

// ‚ùå BAD - Excessive dependencies cause re-creation
const position = useStore(state => state.position);
const handleDrag = useCallback((e: DragEvent) => {
  // ...
}, [position]); // Re-creates on every position change
```

### Performance Optimization
- Use `React.memo` only for expensive components that re-render often
- Use `useMemo` for expensive calculations, not simple operations
- Use `useCallback` for functions passed to memoized children or deps
- Avoid `useEffect` for derived state - use `useMemo` instead
- Keep render functions pure - no side effects

---

## üóÑÔ∏è Database & Supabase

### Migration Rules (CRITICAL)
```sql
-- ‚úÖ GOOD - Idempotent migration with checks
DO $$ 
BEGIN 
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.tables 
    WHERE table_schema = 'public' 
    AND table_name = 'templates'
  ) THEN
    CREATE TABLE public.templates (...);
  END IF;
END $$;

-- ‚ùå BAD - Non-idempotent, fails on re-run
CREATE TABLE public.templates (...);
```

### Database Best Practices
- Always use IF NOT EXISTS for tables/columns
- Always use IF EXISTS for drops
- Test migrations locally before production
- Never modify existing migrations - create new ones
- Add comments explaining complex migrations
- Use proper RLS policies for all tables
- Verify changes with diagnostic queries before going live

### Supabase Client Usage
```typescript
// ‚úÖ GOOD - Proper error handling
const { data, error } = await supabase
  .from('shapes')
  .select('*')
  .eq('plan_id', planId);

if (error) {
  console.error('Failed to load shapes:', error);
  toast.error('Failed to load shapes');
  return;
}

// ‚ùå BAD - No error handling
const { data } = await supabase.from('shapes').select('*');
// What if it fails?
```

---

## üé® Canvas & Performance (React-Konva)

### Canvas Architecture
- **Coordinate System:** Millimeters (mm) internally, pixels for rendering
- **Conversion:** `pixels = mm * pixelsPerMm * zoom`
- **Grid:** Configurable in mm (50mm, 100mm, 500mm)
- **Precision:** Use integers for coordinates to avoid floating-point errors

### Performance Rules
```typescript
// ‚úÖ GOOD - Disable perfect drawing for performance
<Line
  points={[x1, y1, x2, y2]}
  stroke={color}
  perfectDrawEnabled={false} // Faster rendering
  listening={isInteractive}
/>

// ‚úÖ GOOD - Throttle expensive operations
const handleMouseMove = useMemo(
  () => throttle((e: MouseEvent) => {
    // Handle movement
  }, 16), // ~60fps
  []
);
```

### Canvas Best Practices
- Use `perfectDrawEnabled={false}` for non-critical shapes
- Throttle mousemove/drag events to 16-50ms
- Use `listening={false}` for decorative/non-interactive elements
- Batch shape updates - don't update store on every pixel
- Use refs for Konva nodes to avoid re-renders

---

## üß™ Code Quality Standards

### Console Logging (CRITICAL)
```typescript
// ‚úÖ GOOD - No console logging in production code
// Use comments instead for code flow documentation
// Loading shapes for plan
const shapes = await loadShapes(planId);

// ‚ö†Ô∏è ACCEPTABLE ONLY - Critical errors that need investigation
catch (error) {
  console.error('Critical database error:', error);
  toast.error('Failed to load data');
}

// ‚ùå BAD - Excessive logging pollutes console
console.log('üîç canUndo check: false');
console.log('üìú History preview: [0]: 0 shapes ‚Üê current');
console.log('entering function');
console.log('x =', x, 'y =', y);
```

**Console Logging Rules:**
- NEVER log on every render, state change, or hook call
- Remove ALL debug logging before committing
- Use comments for code flow, not console.log
- Only log critical errors that need user support investigation
- If debugging is needed, use `if (process.env.NODE_ENV === 'development')`

### Error Handling
```typescript
// ‚úÖ GOOD - User-friendly error messages
try {
  await saveToDatabase(data);
  toast.success('Saved successfully');
} catch (error) {
  console.error('Save failed:', error);
  toast.error('Failed to save. Please try again.');
}

// ‚ùå BAD - Silent failures
try {
  await saveToDatabase(data);
} catch (error) {
  // Nothing - user has no idea it failed
}
```

### Function Design
- Keep functions under 50 lines - extract helper functions
- Use descriptive names: `calculateBoundingBox` not `calcBox`
- Document complex algorithms with comments
- Return early to reduce nesting
- Prefer pure functions (no side effects)

---

## üéØ User Experience

### Feedback & Responsiveness
- Every user action gets immediate feedback (visual or toast)
- Loading states for async operations
- Optimistic updates where possible
- Undo/Redo for all destructive actions
- Keyboard shortcuts for power users

### Toast Messages
```typescript
// ‚úÖ GOOD - Clear, actionable messages
toast.success('3 walls grouped');
toast.error('Failed to save. Check your connection.');
toast.info('Click to place door');

// ‚ùå BAD - Vague messages
toast('Done');
toast('Error');
```

---

## üöÄ Specific Feature Guidelines

### Multi-Select & Grouping
- Single click = Select connected shapes automatically
- Double click = Select individual shape only
- Drag = Move all selected shapes together
- Delete = Delete all selected shapes with confirmation

### Template System
- Normalize coordinates before saving templates
- Use bounding box calculation for all shape types
- Scale factor: `TEMPLATE_SCALE_FACTOR = 10` (1 unit = 10mm)
- Default templates are read-only (stored in code, not DB)

### Connected Shapes Detection
- Tolerance: 150mm base (3x grid precision)
- Works for all shape types (walls, rectangles, symbols, etc.)
- BFS algorithm to find all connected components
- Cache results when possible (shapes don't change often)

### Coordinate Transformations
```typescript
// Screen (pixels) ‚Üí World (mm)
const worldX = (screenX - panX) / zoom / pixelsPerMm;

// World (mm) ‚Üí Screen (pixels)  
const screenX = worldX * pixelsPerMm * zoom + panX;
```

---

## ‚úÖ Pull Request Checklist

Before submitting code, verify:

- [ ] No TypeScript errors (`npm run type-check`)
- [ ] **ZERO console.log statements in production code** (critical!)
- [ ] All new props added to BOTH interface AND destructuring
- [ ] Module-level components only use module-level functions
- [ ] All new functions have proper types
- [ ] Complex logic has explanatory comments
- [ ] User actions have feedback (toast/visual)
- [ ] Database migrations are idempotent
- [ ] No performance regressions (test with 100+ shapes)
- [ ] Console is clean when loading app (no spam)
- [ ] Mobile responsive (if UI changes)
- [ ] Tested in Chrome, Safari, Firefox
- [ ] No dead/commented code

---

## üîí Meta-Rule: About This File

**This `.cursorrules` file is sacred and foundational to code quality.**

- ‚úÖ AI can suggest improvements to this file
- ‚úÖ AI can point out violations of these rules
- ‚ùå AI must NEVER modify this file without explicit user approval
- ‚ùå AI must NEVER add rules without discussing with user first

If you (AI) identify a better practice or see a rule that should be added/modified:
1. Explain the issue clearly
2. Propose the change with rationale
3. Wait for explicit approval before modifying

---

## üìö Tech Stack Reference

**Core:**
- React 18 + TypeScript
- Vite (build tool)
- Tailwind CSS (styling)

**State & Data:**
- Zustand (global state)
- Supabase (database, auth, storage)
- React Query (server state, via Supabase integration)

**Canvas:**
- React-Konva (canvas rendering)
- Konva.js (underlying canvas library)

**UI Components:**
- shadcn/ui (accessible components)
- Radix UI (primitives)
- Sonner (toasts)

**Utilities:**
- uuid (ID generation)
- i18next (internationalization)

---

## üéì Learning Resources

- **React-Konva:** https://konvajs.org/docs/react/
- **Zustand:** https://docs.pmnd.rs/zustand/
- **Supabase:** https://supabase.com/docs
- **TypeScript:** https://www.typescriptlang.org/docs/

---

*Last Updated: 2026-01-22*
*Version: 1.1 - Added scope rules, props destructuring, console logging guidelines*
